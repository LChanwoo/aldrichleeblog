---
title: '컴투스 블록체인 게임서버개발자 양성과정 5주차 회고'
date: '2023-11-13'
tags: ['회고', '컴투스', '블록체인', '게임서버', '개발자', '양성과정']
category: '컴투스 게임서버개발자 양성과정 주간회고'
draft: false
summary: '5주차의 회고입니다.'
---

# 5주차 회고

### 1. 주간회고

새로운 한 주가 시작되었다. 과연 나는 어제의 나보다, 지난 달의 나보다, 작년의 나보다 성장한 것일까? 가슴 속에 작지만 영향력이 큰 의문을 품으며 한 주를 시작한 지 거의 한 달이 되어간다. 이번 주에는 강사님이 바뀌고, 지금까지 배운 리눅스 기초를 복습하며 지난 2주간을 돌아보는 시간을 가졌다.

리눅스의 스왑 메모리라는 것을 배웠다. 예전에 [**모의 코인 투자 사이트**]를 토이 프로젝트로 만들었을 때 사용해 본 적이 있는 것이었다. 그 때는 아무것도 알지 못한 채로 사용했었다. 단지 npm i와 npm build 명령어 실행 도중 AWS 프리티어 EC2 인스턴스가 먹통이 되어 재부팅하는데 30분씩 걸리는 상황에서 어렵게 찾은 해결 방법이었을 뿐이었다. 또한 그 당시에는 파티션을 나눠서 사용하지도 않았다. 그래서 파티션을 나눠서 하는 것은 새로웠다.

수업을 못 따라가서 따로 시작한 운영체제 공부도 잘 되고 있다. 마침 스왑 메모리를 배운 날 운영체제 책에 스왑 메모리에 대해서 나와서 스왑 메모리에 대해 더 잘 알게 된 것 같다. 쉽게 말하면 메모리가 부족할 때 잠깐 하드디스크(스왑 메모리)에 초과하는 메모리를 저장했다가 메모리에 공간이 생기면 하드디스크에 저장했던 메모리를 다시 가져와서 작업을 수행한다는 것인 듯 하다. 그 외에도 커널 인터럽트, 시스템 콜, 프로세스 등을 공부 했다. 강은아 강사님께서 말씀하신 “IT는 다 비슷비슷하다”라는 말이 무슨 뜻인지 알게 된 것 같기도 하다.

프로세스는 메모리에 올라가서 실행 중인 프로그램을 의미한다. 프로세스에서 함수 코드를 호출할 때, 프로그램 메모리의 스택 영역에 지금 실행 중인 코드 위치를 저장하고, 함수를 호출하여 실행한 다음, 함수 코드 실행이 완료되면 원래 실행 중이던 위치 정보를 스택 영역으로부터 받아서 돌아간다. 이후 다음 코드를 실행한다.

커널은 메모리 상에 올라간 운영체제의 영역이다. 한번에 운영체제 전체가 메모리에 올라갈 경우 너 무 많은 영역을 차지하므로, 최소한으로 필요한 운영체제 부분을 메모리에 올리는데 이것이 커널이다. 커널에서는 커널 함수를 호출하여 사용한다. 커널 함수란 사용자가 직접 사용하면 위험한 코드를 운영체제에서 실행하는 함수를 말한다. 사용자 프로그램의 프로세스에서 입출력 등의 인터럽트로 커널 함수의 사용을 요청하는 것을 시스템 콜이라고 하는데, 이 시스템 콜을 사용할 때도 현재 실행 중인 프로세스의 정보를 커널의 스택 영역에 저장하고, 시스템 콜의 작업이 끝나면 스택 영역으로부터 실행 중이던 프로세스 정보를 가져와서 프로세스를 계속해서 실행한다.

즉, 기본적으로 운영체제와 관련된 작업들은 일을 하던 중에 무슨 일이 생기면 다른 어딘가에 정보를 맡기고, 다시 실행할 준비가 되면 다시 받아와서 일을 수행한다. 이 과정이 어디서 일어나느냐에 따라 실행 주체가 다른 용어로 바뀌는 것일 뿐 결국에는 전부 똑같은 과정인 것이다.

CPP에 대해서 조금 더 알게 된 것 같다. 아래와 같은 일이 있었다.

<Image alt="" src="/static/images/reminiscence/1.png" width={800} height={800} />

나는 이 문제를 분명히 맞게 풀었다. 그럼에도 불구하고 틀렸다고 이 악물고 덤벼드는 채점 프로그램에 정신을 잃을 뻔 했다. 아래는 각각 이 문제의 오답 코드와 성공 코드이다

```cpp
//오답코드
#include <iostream>
#include <vector>
#include <algorithm>
#include <utility>
using namespace std;

int main(){
    int N,a,b;
    cin >> N;
    vector<pair<int,int>> v;
    for(int i=0;i<N;i++){
        cin >> a >> b;
        v.push_back(make_pair(a,b));
    }
    sort(v.begin(),v.end());
    for(int i=0; i < N ; i++){
        cout << v[i].first << " "
				<< v[i].second << endl;
    }
    return 0;
}
```

```cpp
//성공코드
#include <iostream>
#include <vector>
#include <algorithm>
#include <utility>
using namespace std;

int main(){
    int N,a,b;
    cin >> N;
    vector<pair<int,int>> v;
    for(int i=0;i<N;i++){
        cin >> a >> b;
        v.push_back(make_pair(a,b));
    }
    sort(v.begin(),v.end());
    for(int i=0; i < N ; i++){
        cout << v[i].first << " "
				<< v[i].second << '\n';
    }
    return 0;
}
```

너무나 근소한 차이로 성공과 실패가 나뉜다.

C++이라는 언어는 굉장히 섬세한 언어라는 것을 알게 되었다.

마지막으로 JIRA를 이용한 DSM을 시작한 지 이제 3주차가 되었다. 아직은 조원들과 프로젝트를 진행하는 게 없기 때문에 **하루 공부 계획 표** 같은 느낌이지만, 이제는 안하면 허전한 느낌이 든다. 매일 아침 계획을 짜고 실행하는 게 일과가 되었다.

---

### 2. 학습한 내용

- 리눅스
  - 확장권한
  - 작업스케쥴링
  - 디스크 관리
  - 파일시스템 및 스왑메모리
  - 논리 볼륨 관리
  - systemd, systemctl
  - 로그 관리
  - 리눅스 부트 프로세스
  - YUM
  - 네트워크 관리
- 운영체제
  - 커널, 인터럽트, 시스템 콜 등
- 알고리즘
  - 스택, 큐
- cocos2dJS
  - 기본 구조

---

### 3. 유지 중인 것. 보완이 필요한 내용

- 깃 허브 커밋 17일 연속 유지 중

  <Image alt="" src="/static/images/reminiscence/2.png" width={800} height={800} />

- 백준 잔디 심기 14일 연속 유지 중
  <Image alt="" src="/static/images/reminiscence/3.png" width={800} height={800} />

---

### 4. 현재의 내가 지난주보다 발전한 사항

- 백준 티어 **실버4** → **실버3** 달성
- [solved.ac](http://solved.ac) **『이 멋진 수열에 쿼리를!』** 프로필 배경 획득

  <Image alt="" src="/static/images/reminiscence/4.png" width={800} height={800} />

- 이번 주 공부 계획을 Round Robin 방식으로 스케쥴링함 ⇒ 효과 좋음
- 지난 주
  {' '}
  <Image alt="" src="/static/images/reminiscence/5.png" width={800} height={800} />- 시간을 넉넉하게
  두고 계획을 세웠을 때는 제 시간 안에 끝내지 못할 때가 많았다. - 또한 앞의 계획을 제대로 끝내지
  못해서 뒤의 계획이 밀리는 일이 발생하였다.
- 이번 주
  {' '}
  <Image alt="" src="/static/images/reminiscence/6.png" width={800} height={800} />- 이번 주는
  CPU스케쥴링 방식 중 하나인 Round Robin 방식을 채용하여 계획을 세우고 실행하였다. - 10분 단위로
  시간을 쪼개고, 시간이 부족하면 맨 뒤로 밀어서 나중에 다시 하는 방식으로 진행하였더니, 옛날에
  비디오게임 **Outlast**를 하며 **타임 어택**하던 때의 기억이 나서 오히려 즐기면서 할 수 있었고,
  즐기면서 했더니 10분, 20분밖에 안되는 시간이지만 오히려 시간이 남았다. - 새로운 시간 관리 방법을
  찾을 때까지는 이 방법을 사용해야겠다.
